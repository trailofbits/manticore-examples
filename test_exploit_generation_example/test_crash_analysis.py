#
# Usage: python crash_analysis.py ./prog  -- argv_conc -- arg_symbolic
#
# manticore uses '+' to know which parts of the argv are symbolic.
# In our example it gives:
# python crash_analysis.py ./bof  -- AAAAAAAAAAAAAAAAAAAAAAA -- +++++++++++++++++++++++
#
import sys
from manticore.native import Manticore


def concrete_run(prog, params):
    print("Starting concrete execution")

    m = Manticore(prog, params)
    # 'trace' will contain the executed instructions
    m.context["trace"] = []

    # None: The hook will be applied to all the instructions
    @m.hook(None)
    def record_trace(state):
        pc = state.cpu.PC

        # Store the instruction
        with m.locked_context() as c:
            c["trace"] += [pc]

    m.run()

    # Print number of instructions recorded

    with m.locked_context() as c:
        print("%d instructions are recorded" % len(c["trace"]))
        return c


def symbolic_run(prog, params, trace, pc_crash):
    print("Starting symbolic execution")

    trace_set = set(trace)
    m = Manticore(prog, params)

    # The hook will be applied only to the instruction @pc_crash
    @m.hook(pc_crash)
    def crash_analysis(state):
        # Add the constraint on eax
        state.constrain(state.cpu.EAX == 0x0804887C)  # 0x0804887c = @call_me
        # Retrieve the arguments corresponding to argv[1]
        argv_1 = next((i for i in state.input_symbols if i.name == "ARGV1"), None)
        if argv_1:
            # Ask the value of argv_1 to the solver
            val_argv_1 = state.solve_one(argv_1)
            # Pretty print of the solution
            print("The solution is:")
            print("\\x" + "\\x".join("{:02x}".format(c) for c in val_argv_1))
        state.abandon()

    # trace contains the list of instructions previously recorded
    trace_set = set(trace)  # convert the list to a set

    # None: The hook will be applied to all the instructions
    @m.hook(None)
    def follow_trace(state):
        if "visited" not in state.context:
            state.context["visited"] = set()
        state.context["visited"].add(state.cpu.PC)

        # We stop to explore the current path if it doesn't follow the targeted path
        if not state.context["visited"] <= trace_set:
            print("State diverge at 0x%x" % state.cpu.PC)
            state.abandon()

    m.run()


def test():
    targeted_prog = ""
    concrete_argv = ""
    symb_argv = ""
    if __name__ == "__main__":

        first_placeholder = 0
        last_placeholder = 0
        targeted_prog = sys.argv[1]

        # Look for the "--" placeholders
        for i in range(0, len(sys.argv)):
            argv = sys.argv[i]
            if argv == "--":
                if first_placeholder > 0:
                    last_placeholder = i
                else:
                    first_placeholder = i

        # Look for the concrete and symbolic arguments
        concrete_argv = sys.argv[first_placeholder + 1 : last_placeholder]
        symb_argv = sys.argv[last_placeholder + 1 :]
    else:
        targeted_prog = "test_exploit_generation_example/bof"
        concrete_argv = ["AAAAAAAAAAAAAAAAAAAAAAA"]
        symb_argv = ["+++++++++++++++++++++++"]

    # Launch the concrete execution
    context = concrete_run(targeted_prog, concrete_argv)

    # Launch the symbolic execution
    # We use the last element of context['trace'] to determin the crashing instruction
    symbolic_run(targeted_prog, symb_argv, context["trace"], context["trace"][-1])


if __name__ == "__main__":
    test()
