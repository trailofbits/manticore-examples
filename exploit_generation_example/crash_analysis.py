# 
# Usage: python crash_analysis.py ./prog  -- argv_conc -- arg_symbolic
# 
# manticore uses '+' to know which parts of the argv are symbolic.
# In our example it gives:
# python crash_analysis.py ./bof  -- AAAAAAAAAAAAAAAAAAAAAAA -- +++++++++++++++++++++++ 
#
import sys
from manticore import Manticore

def concrete_run(prog, params):
    print "Starting concrete execution"

    m = Manticore(prog, params)
    # 'trace' will contain the executed instructions
    m.context['trace'] = []

    # None: The hook will be applied to all the instructions
    @m.hook(None)
    def record_trace(state):
        pc = state.cpu.PC

        # Store the instruction
        m.context['trace'] += [pc]      

    m.run()

    # Print number of instructions recorded
    print "%d instructions are recorded" % len(m.context['trace'])

    return m.context

def symbolic_run(prog, params, trace, pc_crash):
    print "Starting symbolic execution"

    trace_set = set(trace)
    m = Manticore(prog, params)

    # The hook will be applied only to the instruction @pc_crash 
    @m.hook(pc_crash)
    def crash_analysis(state):
        # Add the constraint on eax
        state.constrain(state.cpu.EAX == 0x0804887c) # 0x0804887c = @call_me
        # Retrieve the arguments corresponding to argv[1]
        argv_1 = next((i for i in state.input_symbols if i.name == 'ARGV1_1'), None)
        if argv_1:
            # Ask the value of argv_1 to the solver
            val_argv_1 = state.solve_one(argv_1)
            # Pretty print of the solution
            print "The solution is:"
            print "\\x"+"\\x".join("{:02x}".format(ord(c)) for c in val_argv_1)
        state.abandon()

    trace_set = set(trace) # convert the list to a set
    
    # None: The hook will be applied to all the instructions
    @m.hook(None)
    def follow_trace(state):
        # visited is composed of couples, we only need the address here
        visited = {addr for (_, addr) in state.visited}

        # We stop to explore the current path if it doesn't follow the targeted path
        if not visited <= trace_set:
            print "State diverge at 0x%x" % state.cpu.PC
            state.abandon()

    m.run()


if __name__ == '__main__':

    targeted_prog = sys.argv[1]

    first_placeholder = 0
    last_placeholder = 0

    # Look for the "--" placeholders
    for i in range(0, len(sys.argv)):
        argv = sys.argv[i]
        if argv == '--':
            if first_placeholder > 0:
                last_placeholder = i
            else:
                first_placeholder = i

    # Look for the concrete and symbolic arguments
    concrete_argv = sys.argv[first_placeholder + 1: last_placeholder]
    symb_argv = sys.argv[last_placeholder + 1:]

    # Launch the concrete execution
    context = concrete_run(targeted_prog, concrete_argv)

    # Launch the symbolic execution
    # We use the last element of context['trace'] to determin the crashing instruction
    symbolic_run(targeted_prog, symb_argv, context['trace'], context['trace'][-1])
